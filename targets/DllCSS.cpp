
#include "DllDirectX.hpp"
#include "Version.hpp"
#include <stdlib.h>
#include <time.h>  
#include "aacc_2v2_ui_elements.h"
#include <array>

#define SAFEMOD(a, b) (((b) + ((a) % (b))) % (b))

std::map<int, std::array<DWORD, 64>> paletteColorMap = { // what happens when i get tired
{0,{{0xFF652C54,0xFFFEB8C6,0xFF9FB0F2,0xFF4C6732,0xFF462C54,0xFF7B4235,0xFFA953A2,0xFFBD170A,0xFF3A8698,0xFF1A2CCD,0xFF2A2D2D,0xFFDAE2EB,0xFFFFBF70,0xFF8E2244,0xFF377F54,0xFF292929,0xFF660D0F,0xFF2E2E2E,0xFF2E4984,0xFF8B8B8E,0xFF88A6B0,0xFF792171,0xFFFCF773,0xFF4C1A21,0xFF53566E,0xFF8356B7,0xFFFF8011,0xFF8B4276,0xFF2D2D72,0xFFDAC6FF,0xFFB9E0FF,0xFFC84A21,0xFF265554,0xFF5C619F,0xFFFF9FB4,0xFF792C21,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{1,{{0xFF904080,0xFF7B2838,0xFF4D8E50,0xFFC0ACE1,0xFF3C4080,0xFF363333,0xFF63568B,0xFFA27B46,0xFFF8DCF8,0xFFC9180C,0xFF733355,0xFF274C50,0xFF46203F,0xFF9040AE,0xFFDD4C37,0xFF3F403E,0xFF323D6A,0xFF567BBD,0xFFF8B3CA,0xFFA2C5D5,0xFFE198B6,0xFF4F3573,0xFFFDFFFB,0xFF4F3846,0xFFA2ACF8,0xFFFFD2EE,0xFF8037A9,0xFFB01600,0xFF94967A,0xFFCED0D3,0xFF3B4080,0xFFE06780,0xFF3B5C42,0xFFE5C85A,0xFF795C4F,0xFF0F0F0C,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{2,{{0xFF3F465D,0xFFF2F2F5,0xFF774F88,0xFF56A284,0xFF3B3B3B,0xFF9C6035,0xFF988463,0xFF56598E,0xFF5A388B,0xFFFF0000,0xFF644649,0xFF222429,0xFF8E95A4,0xFF4C2C53,0xFFFFBA3F,0xFFFF8AA3,0xFF3EB57C,0xFF8B1721,0xFF42325D,0xFF4F3524,0xFF842B21,0xFF293460,0xFFD7B9D2,0xFF2E1A2B,0xFFB3F19F,0xFFBAA26E,0xFF671F3B,0xFFB9D0FF,0xFFAF956E,0xFF5C3B71,0xFF8B4D7E,0xFF407185,0xFFDA5C00,0xFF235A30,0xFFFFE55C,0xFF7B5545,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{3,{{0xFFBE0000,0xFF404868,0xFF845692,0xFFA2B0DE,0xFF9FB084,0xFFBDB6B2,0xFF327760,0xFF5D0000,0xFFBED5E1,0xFFF59581,0xFF7DD99F,0xFF8B5166,0xFF580022,0xFF42487E,0xFF6E4C98,0xFF5AD6D7,0xFFFF6B00,0xFFFFF8EE,0xFF747471,0xFF3F3E3C,0xFF2B426D,0xFFC83B55,0xFFCA567B,0xFF322135,0xFFAF9454,0xFFC8556C,0xFF6188FF,0xFFBCBCD4,0xFFFFAAC1,0xFF995CA0,0xFF42804F,0xFF986100,0xFFF94D05,0xFF730000,0xFF7B2961,0xFF333030,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{4,{{0xFF7E4E55,0xFFFD9344,0xFF35466D,0xFF925E84,0xFF6A8163,0xFF842532,0xFF3F4345,0xFF9FB0F2,0xFF7F58AE,0xFFB0B0F0,0xFF35314E,0xFFFADDE2,0xFFAF371B,0xFFFDFDFF,0xFFF51F19,0xFF00E1E1,0xFFFFBDCB,0xFF4E4E4E,0xFF24354F,0xFFFFC6DF,0xFF534235,0xFF884267,0xFFCAB5E1,0xFF46494C,0xFF3A2C69,0xFF304E6E,0xFF526438,0xFFE27B7E,0xFF877E97,0xFF813A70,0xFFE55200,0xFF719052,0xFFBB5873,0xFF42487E,0xFF522938,0xFF424545,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{5,{{0xFF7E4E55,0xFFFD9344,0xFF35466D,0xFF925E84,0xFF6A8163,0xFF842532,0xFF3F4345,0xFF9FB0F2,0xFF7F58AE,0xFFB0B0F0,0xFF35314E,0xFFFADDE2,0xFFAF371B,0xFFFDFDFF,0xFFF51F19,0xFF00E1E1,0xFFFFBDCB,0xFF4E4E4E,0xFF24354F,0xFFFFC6DF,0xFF534235,0xFF884267,0xFFCAB5E1,0xFF46494C,0xFF3A2C69,0xFF304E6E,0xFF526438,0xFFE27B7E,0xFF877E97,0xFF813A70,0xFFE55200,0xFF719052,0xFFBB5873,0xFF42487E,0xFF522938,0xFF424545,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{6,{{0xFF7E4E55,0xFFFD9344,0xFF35466D,0xFF925E84,0xFF6A8163,0xFF842532,0xFF3F4345,0xFF9FB0F2,0xFF7F58AE,0xFFB0B0F0,0xFF35314E,0xFFFADDE2,0xFFAF371B,0xFFFDFDFF,0xFFF51F19,0xFF00E1E1,0xFFFFBDCB,0xFF4E4E4E,0xFF24354F,0xFFFFC6DF,0xFF534235,0xFF884267,0xFFCAB5E1,0xFF46494C,0xFF3A2C69,0xFF304E6E,0xFF526438,0xFFE27B7E,0xFF877E97,0xFF813A70,0xFFE55200,0xFF719052,0xFFBB5873,0xFF42487E,0xFF522938,0xFF424545,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{7,{{0xFF1A4981,0xFF2B2B3C,0xFF3F5953,0xFF77C0C7,0xFFFFCD38,0xFF5667A2,0xFF6B6A71,0xFFB3B6EE,0xFF3A3A3A,0xFFC450FF,0xFF751F38,0xFFFFFEFC,0xFF333F5A,0xFF7DBF7D,0xFF835C5E,0xFF9191AA,0xFFA36BA5,0xFF3F7E49,0xFF2E2E30,0xFFB30000,0xFFFFFEFD,0xFF384667,0xFFFFFCFC,0xFF14243C,0xFF614988,0xFFFF882E,0xFF145257,0xFF764D29,0xFFBE9AC8,0xFF7B006C,0xFFB45C4D,0xFFC6B47E,0xFF1E6CC8,0xFFE29FCB,0xFF484212,0xFF453355,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{8,{{0xFFB92133,0xFF5C5C9D,0xFFFFCA46,0xFF748133,0xFF9F59C7,0xFFFF7700,0xFF404040,0xFFF5F5FF,0xFF3FBFDF,0xFF1A640C,0xFF7D093A,0xFF897AA6,0xFF9F9F9F,0xFF503D5A,0xFF3FFFAF,0xFFAF68FF,0xFF263F79,0xFF564253,0xFFFEFCEE,0xFFC74F8B,0xFF596DB3,0xFF691930,0xFFFEC7E5,0xFF323542,0xFFC14A71,0xFFAFD09A,0xFF797E85,0xFF339A89,0xFFFDFBFF,0xFFE5528B,0xFFFFE595,0xFFB9A2E5,0xFF921983,0xFFFEF9FF,0xFFAA4D12,0xFF3D3D4A,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{9,{{0xFF432D49,0xFFF0F0FF,0xFF77142E,0xFF6A494F,0xFF6D74B0,0xFF35714C,0xFF003F77,0xFF4C141A,0xFF6444A6,0xFF344C81,0xFF7D5F7F,0xFF88247C,0xFF323D53,0xFF6B1638,0xFF781369,0xFFE76919,0xFF4C4B65,0xFF84468B,0xFFAC3747,0xFF98B9EB,0xFF323C3F,0xFF523042,0xFFFCFDFE,0xFF212121,0xFF422B73,0xFF294457,0xFF552D7E,0xFF3D6C64,0xFF4055B1,0xFFDA0C11,0xFF334569,0xFF385224,0xFF6C4240,0xFFB4A257,0xFFACB1B4,0xFF692488,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{10,{{0xFF46465D,0xFF989892,0xFF81715D,0xFF607B5D,0xFF8B0000,0xFFF2D159,0xFF562E46,0xFFFFFCFC,0xFF494949,0xFF465A81,0xFF353846,0xFFFFFFC1,0xFF704629,0xFFB01613,0xFF292929,0xFF82647B,0xFFFF9062,0xFF285635,0xFF4F4981,0xFF3B231C,0xFF601A0D,0xFF2E2E4A,0xFFFEFEFE,0xFF1A242E,0xFFD8D8D8,0xFF695A73,0xFFFF88CE,0xFFFCFBFC,0xFF424A1C,0xFF262426,0xFF306C85,0xFFF78330,0xFF858829,0xFF923088,0xFF8B7E88,0xFF643B85,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{11,{{0xFF65413E,0xFF7B0D1A,0xFF4C63B6,0xFFF7BF1D,0xFF65813E,0xFFF2EBDB,0xFF11245D,0xFF35414F,0xFFEB2E07,0xFF6541B5,0xFF65A93E,0xFF654178,0xFFE1F5E4,0xFF384E62,0xFF7F1F3E,0xFFD986A9,0xFF2C2C2C,0xFFEBEEFC,0xFF452B32,0xFFAC2135,0xFF9C245D,0xFF522436,0xFFFFFFF8,0xFF322B35,0xFF920000,0xFF528D7B,0xFF76577E,0xFFAA887B,0xFFAE8ABA,0xFF7E56B6,0xFFAAE2FC,0xFF5245A2,0xFFC18BE2,0xFFC14F26,0xFF5D5F5F,0xFF367367,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{12,{{0xFF86546C,0xFFA595A0,0xFFAC6A9C,0xFF4F6AA9,0xFF8B1E00,0xFFEEB61A,0xFF4C4949,0xFF1A3C7E,0xFFABA175,0xFF5D2444,0xFF532C62,0xFF645453,0xFF861800,0xFF40000D,0xFF75A352,0xFF842C57,0xFFCF3051,0xFF38495D,0xFF714981,0xFFA91111,0xFF4F305D,0xFF482660,0xFF9C6AAA,0xFF212121,0xFF7148A2,0xFF9A9FC4,0xFF95D3FF,0xFF75487A,0xFF9F8052,0xFFF4EA92,0xFFA2385A,0xFF2B3D76,0xFF909092,0xFF296764,0xFF674026,0xFFA49DE7,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{13,{{0xFFA10000,0xFF645453,0xFF566D9C,0xFF3B5B4A,0xFFCD88B0,0xFFCAB6AC,0xFFAC711E,0xFFAF0D27,0xFF5A2444,0xFFFBFAFA,0xFFFFABC1,0xFFFFF5A1,0xFF6B3948,0xFFB3A29C,0xFF44A485,0xFFFF9412,0xFFFFDEF3,0xFF548A62,0xFF59241A,0xFF404868,0xFFB93221,0xFF81004F,0xFFE7CCCD,0xFF550F1F,0xFFB1A4D8,0xFF793648,0xFF9790CB,0xFF455283,0xFFC45D6C,0xFF4D4D4D,0xFFD88B00,0xFFC80000,0xFF6E0069,0xFFFF8DB9,0xFF95B4F2,0xFF2F2D2B,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{14,{{0xFF653403,0xFF383838,0xFF816781,0xFF920000,0xFF322E53,0xFFFFC300,0xFF2846B6,0xFF01A9D1,0xFF65B595,0xFFFAEBFF,0xFF5A5A58,0xFF8E343D,0xFF0050AB,0xFF9C1C33,0xFF64E15B,0xFF5D356F,0xFFFF648C,0xFF4B5A6D,0xFFDE7EA2,0xFF216735,0xFF8B53A2,0xFF3F3F3F,0xFFC8C8D3,0xFF6A3C4F,0xFF84B0E5,0xFFA4346C,0xFF73644F,0xFF48736E,0xFF4F4A67,0xFFEAA74A,0xFF3D4876,0xFF7B5592,0xFF878689,0xFF7B0A4A,0xFFEAA4DA,0xFF9AC8EC,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{15,{{0xFF072D69,0xFF7B0D1A,0xFF1F6151,0xFF88609F,0xFFE8F2FF,0xFFDECAFF,0xFF243C74,0xFFA92B2B,0xFFFFFFDC,0xFF89A6DC,0xFF848481,0xFF423538,0xFF5F0E38,0xFFFFDBE5,0xFF874B4B,0xFF5B823C,0xFFCDB991,0xFF492D69,0xFF8E4263,0xFFD7CAB3,0xFF353535,0xFF2E3B7B,0xFFF2F5FF,0xFF32322E,0xFFEFEAD3,0xFFD0A4C1,0xFF90008D,0xFF52927E,0xFF364AA7,0xFF422B2E,0xFFC8CBC6,0xFF6C4A4F,0xFFA73D00,0xFFECB919,0xFF24453B,0xFFCE2495,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{17,{{0xFFF8C01E,0xFF426C59,0xFF6371DE,0xFFCAB6AC,0xFF3C3C4C,0xFF354274,0xFF144423,0xFFA6ACB0,0xFF555553,0xFFD2B08E,0xFFFFC1B0,0xFF444266,0xFF2D9C5F,0xFF816EBA,0xFF50465A,0xFF915FD7,0xFF293155,0xFFF5CEE8,0xFFA9886D,0xFFFFF5AC,0xFF742B32,0xFFC7BFE4,0xFFF8ACBD,0xFF755C63,0xFF383838,0xFF305386,0xFFAA6B6B,0xFFBAFF91,0xFF141515,0xFFA24F79,0xFFB40200,0xFF1E5236,0xFFD89A1C,0xFF724D8D,0xFFC4CEFF,0xFF363636,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{18,{{0xFF3A3A3E,0xFFCD678B,0xFFCDA6FF,0xFF7B8EC3,0xFF5D743E,0xFF463A3E,0xFFFFF2EB,0xFF28355D,0xFF73626C,0xFF393947,0xFFAC8CA4,0xFF313A3E,0xFF2A6224,0xFF8E0800,0xFF704293,0xFF414042,0xFF223A55,0xFF833856,0xFF6D568B,0xFFFAFCFD,0xFF474242,0xFF4C4E6A,0xFF282632,0xFFFCFCFF,0xFF124226,0xFFF99AAF,0xFFFFB600,0xFF9D1C24,0xFF40335A,0xFF4F264D,0xFF424DA2,0xFFACACAC,0xFF4A3A6E,0xFF367679,0xFF4A3669,0xFFE2B2BA,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{19,{{0xFF1D538E,0xFF980035,0xFF000162,0xFFCB1800,0xFFFFCD00,0xFF50DFE6,0xFF54328B,0xFFE8AB33,0xFFF5EBF7,0xFF89EDDA,0xFF18BAF4,0xFFEBC107,0xFFFF787A,0xFF66AE44,0xFFFFFAFC,0xFFE62C6E,0xFF225F3D,0xFFFFDAD0,0xFF3F1649,0xFF8CBCB4,0xFFB51F78,0xFF478904,0xFF2CB7EB,0xFFA13158,0xFF2CB7EB,0xFFFF8958,0xFF3C1E27,0xFF1378B7,0xFFDCFF5D,0xFFFAAE24,0xFF44AB75,0xFFE4C444,0xFFE49ABA,0xFFE4315D,0xFF66D0DC,0xFF522165,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{20,{{0xFFF8D46E,0xFFD18E6A,0xFFFFC3D1,0xFF283C7B,0xFFCDC7B0,0xFFB6D46E,0xFFAC5346,0xFF7E6A60,0xFFFFD667,0xFFD3D3D3,0xFFF8B06E,0xFFF80000,0xFFFF6F6D,0xFF939393,0xFF82B61E,0xFFFF8E1E,0xFFBE83FF,0xFFB99F6E,0xFF607EC7,0xFFC4B4A2,0xFFC095F2,0xFFFFE8B0,0xFFFFFCF8,0xFFFFDB9F,0xFFFFD66B,0xFF61A8A1,0xFFF86B91,0xFFE36400,0xFFFFFFA9,0xFFFCC1F9,0xFFB92100,0xFF074DA7,0xFF1E7B24,0xFFB67114,0xFFE071A4,0xFF6C369A,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{22,{{0xFFC30000,0xFF344053,0xFFB9CAFF,0xFF748E53,0xFFF2B321,0xFF954F6A,0xFFDB0021,0xFF353C7E,0xFFB21800,0xFF35C4ED,0xFF84FF33,0xFFCD9C00,0xFF7650AA,0xFF00ABCB,0xFF8B5166,0xFF12584E,0xFFE11E14,0xFFF5C0D4,0xFFFEF975,0xFFBD0721,0xFFE59FB0,0xFFD7288E,0xFFE4DDD4,0xFF6A1E21,0xFFFFE580,0xFF696473,0xFF8D4871,0xFF455736,0xFF006D71,0xFFC8BCDD,0xFF2C5E36,0xFF760000,0xFF9D9D9A,0xFF7B5A42,0xFFFFE557,0xFF2A2F2B,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{23,{{0xFFFCFCFF,0xFFDB88A2,0xFFBAB0E5,0xFFD7A156,0xFF4F8987,0xFF9BBECF,0xFF7275B0,0xFF876655,0xFF4C4749,0xFF296F36,0xFFACC3E7,0xFFE7ACB0,0xFFFFFCCF,0xFF8AB5FC,0xFF98283F,0xFFC8676E,0xFF4E517B,0xFFCBC8FC,0xFFCB80DA,0xFF35526C,0xFF9D9B8B,0xFFBCCAD8,0xFF797C80,0xFF29292B,0xFFD58D8D,0xFF7F0C42,0xFF4C4CAE,0xFFB6F8F9,0xFFA77379,0xFF5D453B,0xFF7CA55A,0xFFEC9236,0xFF97B6D0,0xFF805C4C,0xFF8B64A2,0xFF2D3E67,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{24,{{0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{25,{{0xFF78787B,0xFFBFBFBF,0xFF7D4A34,0xFF37553E,0xFFFFF2E8,0xFF847167,0xFF624558,0xFF948041,0xFF55555C,0xFFCCAACC,0xFF635252,0xFFFEFEC0,0xFFA8917D,0xFF3D5255,0xFFA1510E,0xFF8389CC,0xFFBF8DA4,0xFF6559AC,0xFFFDFCFE,0xFFFDF874,0xFF8D1D20,0xFFB2B1A8,0xFF4F677E,0xFF1D1C26,0xFFA6B4BC,0xFF56357E,0xFFFF88CE,0xFF1F2D52,0xFF583F2E,0xFFCC0001,0xFF306C85,0xFFF78330,0xFF40422A,0xFF923088,0xFF8A7C88,0xFF623985,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{26,{{0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{27,{{0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{28,{{0xFF404868,0xFF4C3A3E,0xFF74353F,0xFF144C32,0xFFA7ACD1,0xFFA96D8B,0xFF6D4C38,0xFF816AA9,0xFF670202,0xFF4D4742,0xFF612C76,0xFF42487E,0xFFB74E00,0xFF3F5A3A,0xFFF58E00,0xFFC1C9C0,0xFFBD6658,0xFF710A00,0xFF1A3249,0xFF9C585D,0xFF634E88,0xFF3F3C35,0xFFFFFDFD,0xFF712459,0xFF7C3853,0xFF4C4848,0xFF900C14,0xFF24555A,0xFFC3AFE2,0xFFCE6900,0xFF626366,0xFF528568,0xFF795A42,0xFFF9D042,0xFFC6C4C5,0xFF5C3B68,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{29,{{0xFFD5D9FF,0xFF214260,0xFF23423A,0xFF444260,0xFF7A2442,0xFF5D90AE,0xFFB76425,0xFF7A181A,0xFF5FA664,0xFF8962AB,0xFF313A66,0xFFFD9344,0xFF755D42,0xFFFFDFE4,0xFF3E3E4A,0xFF5A4947,0xFF282929,0xFFE2E0E4,0xFFEA4D76,0xFF9D7E60,0xFF3D8DFF,0xFF14B98D,0xFFB5A1E6,0xFF1A1E23,0xFFFF89B5,0xFF99D19E,0xFFB13230,0xFFFAEBCB,0xFF697F87,0xFFD73131,0xFF275A4C,0xFF5F3F29,0xFF7A4260,0xFFE6BF42,0xFF383838,0xFF9C244C,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{30,{{0xFFFFFFFF,0xFF702C44,0xFFA69C6F,0xFF293460,0xFFD5849C,0xFF2E313D,0xFFC9C2C0,0xFFD79A27,0xFFD2B6DF,0xFFFFC4BC,0xFF5D497A,0xFF313D58,0xFFC4758E,0xFF1D5D16,0xFF982962,0xFF845347,0xFF1F423D,0xFFE490BC,0xFFE26690,0xFF18A58D,0xFFCDE8C9,0xFFFF2600,0xFF0C446C,0xFF292424,0xFF8787BF,0xFF9F7B5B,0xFF44325A,0xFF732035,0xFFE6DF66,0xFF5F3849,0xFF1F472C,0xFF8B2741,0xFF3D3F7D,0xFFFFCD13,0xFF5F3D2C,0xFF646565,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{31,{{0xFF525258,0xFF354969,0xFFB573A1,0xFF939C8E,0xFF6E5A29,0xFF663D3A,0xFF7D294C,0xFF2C2D2E,0xFFFF90AE,0xFF646440,0xFF814C93,0xFF86B5AB,0xFFC11D13,0xFF90867D,0xFFCDBA9A,0xFFDF4729,0xFF3A509A,0xFF352E31,0xFF295D4C,0xFF86694C,0xFFA67398,0xFF928C98,0xFFDBD6CB,0xFF53203D,0xFFD05FE8,0xFFFF8334,0xFF334973,0xFF4E8670,0xFF687DAF,0xFF3A3D42,0xFF476E73,0xFF9A002E,0xFFDA9A27,0xFF62427F,0xFF3F4970,0xFFFFFFFF,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{32,{{0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF412F3B,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{33,{{0xFF5C68A0,0xFFFCFDFC,0xFFA4CB93,0xFF75B2E4,0xFFF5D049,0xFF6E5AA6,0xFF529296,0xFF9C5A70,0xFF5C49A0,0xFFC4BAA7,0xFFC9813F,0xFF444266,0xFF6B4E53,0xFF3D3D3D,0xFF49507D,0xFF842950,0xFF477A6E,0xFFCE4240,0xFFFFFFFF,0xFFE5A7E2,0xFFFFFFB4,0xFF3A6966,0xFFCBB5DC,0xFF151313,0xFF80797B,0xFFA77985,0xFF6E835A,0xFF223A55,0xFF644935,0xFFF0DC5D,0xFF4C6684,0xFF624784,0xFFCB9CB0,0xFF664229,0xFF981A22,0xFF4F5052,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{34,{{0xFF653403,0xFF383838,0xFF816781,0xFF920000,0xFF322E53,0xFFFFC300,0xFF2846B6,0xFF01A9D1,0xFF65B595,0xFFFAEBFF,0xFF5A5A58,0xFF8E343D,0xFF0050AB,0xFF9C1C33,0xFF64E15B,0xFF5D356F,0xFFFF648C,0xFF4B5A6D,0xFFDE7EA2,0xFF216735,0xFF8B53A2,0xFF3F3F3F,0xFFC8C8D3,0xFF6A3C4F,0xFF84B0E5,0xFFA4346C,0xFF73644F,0xFF48736E,0xFF4F4A67,0xFFEAA74A,0xFF3D4876,0xFF7B5592,0xFF878689,0xFF7B0A4A,0xFFEAA4DA,0xFF9AC8EC,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{35,{{0xFF653403,0xFF383838,0xFF816781,0xFF920000,0xFF322E53,0xFFFFC300,0xFF2846B6,0xFF01A9D1,0xFF65B595,0xFFFAEBFF,0xFF5A5A58,0xFF8E343D,0xFF0050AB,0xFF9C1C33,0xFF64E15B,0xFF5D356F,0xFFFF648C,0xFF4B5A6D,0xFFDE7EA2,0xFF216735,0xFF8B53A2,0xFF3F3F3F,0xFFC8C8D3,0xFF6A3C4F,0xFF84B0E5,0xFFA4346C,0xFF73644F,0xFF48736E,0xFF4F4A67,0xFFEAA74A,0xFF3D4876,0xFF7B5592,0xFF878689,0xFF7B0A4A,0xFFEAA4DA,0xFF9AC8EC,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
{51,{{0xFFF8F8F8,0xFF8EC9FF,0xFF9189C6,0xFF9B1C68,0xFF4F3573,0xFFCDBA9A,0xFFAAFCE8,0xFFD2A635,0xFF7A0400,0xFFFAFAFA,0xFF246A5C,0xFF363333,0xFFBC95DF,0xFFE87816,0xFF696BBD,0xFF7B2838,0xFF273D6E,0xFFE1648E,0xFF296764,0xFFCEFF3F,0xFF35527F,0xFFFFEB9C,0xFFD08BC6,0xFF693358,0xFFF8ACBD,0xFFB2B7DD,0xFFD8FFB5,0xFF9AD5DF,0xFF23232A,0xFF70ADFF,0xFFA9E1B2,0xFFF0BCE4,0xFF389ADC,0xFF3D3F7D,0xFFEDD07F,0xFFA6ABBA,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00,0xFF00FF00}}},
};


typedef struct RawInput {
	BYTE dir = 0;
	BYTE btn = 0;
	void set(int playerIndex) {
		DWORD baseControlsAddr = *(DWORD*)0x76E6AC;
		if(baseControlsAddr == 0) {
			return;
		}

		dir = *(BYTE*)(baseControlsAddr + 0x18 + (playerIndex * 0x14));
		btn = *(BYTE*)(baseControlsAddr + 0x24 + (playerIndex * 0x14));
	}
} RawInput;

typedef struct OurCSSData { // variables i want to keep track of
	int idIndex = 0; // what char is hovered, indexed in the below list
	int selectIndex = 0; // what vertical position, char/moon/palette/ready is selected
	int paletteIndex = 0; 
	bool randomPalette = false;
	bool offsetPalette = false;
	RawInput prevInput;
	RawInput input;
	// i should probs just read from where melty gets these,,, but im tired ok? 
	BYTE pressDir() {
		if(prevInput.dir != input.dir) {
			return input.dir;
		}
		return 0;
	}

	BYTE pressBtn() {
		if(prevInput.btn != input.btn) {
			return (prevInput.btn ^ input.btn) & input.btn;
		}
		return 0;
	}

	int holdCounter = 0;
	BYTE holdDir() {

		if(prevInput.dir == input.dir) {
			holdCounter++;
			if(holdCounter > 20) { // strobe the result
				holdCounter = 10;
				return input.dir;
			}
			return 0;
		}
		
		holdCounter = 0;
		return 0; 
	}

} OurCSSData;

typedef struct CSSStructCopy {
	int palette;
	int charID;
	unsigned _unknown1;
	unsigned _unknown2; // possibly port number idek
	int moon;
	unsigned _unknown3;
	unsigned _unknown4;
	unsigned _unknown5;
	unsigned _unknown6;
	unsigned _unknown7;
	unsigned _unknown8;
} CSSStructCopy;

static_assert(sizeof(CSSStructCopy) == 0x2C, "CSSStructCopy must be size 0x2C");

typedef struct CSSStructDisplay {
	unsigned unknown1;
	unsigned cssPhase;
	unsigned portNumber;
	unsigned existsIfMinusOne;
	unsigned gridPos;
	unsigned charID;
	unsigned moon;
	unsigned palette;
	unsigned unknown2;
} CSSStructDisplay;

static_assert(sizeof(CSSStructDisplay) == 0x24, "CSSStructDisplay must be size 0x24");

OurCSSData ourCSSData[4];

CSSStructCopy* players[4] = {
	(CSSStructCopy*)(0x0074d83C + (0 * 0x2C)),
	(CSSStructCopy*)(0x0074d83C + (1 * 0x2C)),
	(CSSStructCopy*)(0x0074d83C + (2 * 0x2C)),
	(CSSStructCopy*)(0x0074d83C + (3 * 0x2C))
};

CSSStructDisplay* dispPlayers[4] = {
	(CSSStructDisplay*)(0x0074D8E8 + (0 * 0x24)),
	(CSSStructDisplay*)(0x0074D8E8 + (1 * 0x24)),
	(CSSStructDisplay*)(0x0074D8E8 + (2 * 0x24)),
	(CSSStructDisplay*)(0x0074D8E8 + (3 * 0x24))
};

constexpr float cssMenuFontSize = 12.0f;
constexpr float cssMenuSelectorWidth = 128.0f;
constexpr int charIDCount = sizeof(charIDList) / sizeof(charIDList[0]); 
const int gridWidth = 9;
const int gridHeight = 6;

int getGoalGridPos(int startGrid, int dir) {

	int x = startGrid % gridWidth;
	int y = startGrid / gridWidth;

	if(dir == 2) {
		y++;
	} else if(dir == 8) {
		y--;
	} else if(dir == 4) {
		x--;
	} else if(dir == 6) {
		x++;
	} else { // direction isnt one of the normal 8, so just ret
		return startGrid;
	}

	if(x < 0) {
		x = gridWidth - 1;
	} else if(x >= gridWidth) {
		x = 0;
	}

	if(y < 0) {
		y = gridHeight - 1;
	} else if(y >= gridHeight) {
		y = 0;
	}

	int newGrid = x + (y * gridWidth);

	// linear search doesnt really matter here
	int newIndex = -1;
	for(int i=0; i<charIDCount; i++) {
		if(charGridList[i] == newGrid) {
			newIndex = i;
			break;
		}	
	}

	if(newIndex == -1) {
		// this means our resulting position was not valid, in which case, we will now recurse. i should maybe add a depth fallback case?
		return getGoalGridPos(newGrid, dir);
	}

	return newGrid;
}

std::function<void(int playerIndex, int dir)> ControlFuncs[] = {

	[](int playerIndex, int dir) mutable -> void {
		//ourCSSData[playerIndex].idIndex = SAFEMOD(ourCSSData[playerIndex].idIndex + dir, charIDCount); 

		int startGrid = charGridList[ourCSSData[playerIndex].idIndex];

		int newGrid = getGoalGridPos(startGrid, dir); 

		// linear search doesnt really matter here
		int newIndex = -1;
		for(int i=0; i<charIDCount; i++) {
			if(charGridList[i] == newGrid) {
				newIndex = i;
				break;
			}	
		}

		if(newIndex == -1) {
			// i could,, and maybe should, recurse here.
			return;
		}

		// reset the palette and moon of the char, now that a new one is here
		players[playerIndex]->moon = 0;
		ourCSSData[playerIndex].paletteIndex = 0;
		ourCSSData[playerIndex].randomPalette = false;

		ourCSSData[playerIndex].idIndex = newIndex;
	},

	[](int playerIndex, int dir) mutable -> void {

		int inc = 0;
		if(dir == 6) {
			inc = 1;
		} else if(dir == 4) {
			inc = -1;
		} else {
			return;
		}

		players[playerIndex]->moon = SAFEMOD(players[playerIndex]->moon + inc, 3);
	},

	[](int playerIndex, int dir) mutable -> void {
		//players[playerIndex]->palette = SAFEMOD(players[playerIndex]->palette + dir, 36);

		if(playerIndex & 1) { // on right side, switch 4/6
			if(dir == 4) {
				dir = 6;
			} else if(dir == 6) {
				dir = 4;
			}
		}

		int currentPalette = ourCSSData[playerIndex].paletteIndex;

		if(ourCSSData[playerIndex].randomPalette) {
			if(dir == 2) {
				ourCSSData[playerIndex].paletteIndex = (ourCSSData[playerIndex].paletteIndex / 6) * 6;
				ourCSSData[playerIndex].randomPalette = false;
			} else if(dir == 8) {
				ourCSSData[playerIndex].paletteIndex = ((ourCSSData[playerIndex].paletteIndex / 6) * 6) + 5;
				ourCSSData[playerIndex].randomPalette = false;
			}
			return;
		}

		if( ((currentPalette % 6) == 0 && dir == 8) || ((currentPalette % 6) == 5 && dir == 2) ) {
			ourCSSData[playerIndex].randomPalette = true;
			return;
		}

		int paletteInc = 0;

		switch(dir) {
			case 2:
				paletteInc = 1;
				break;
			case 8:
				paletteInc = -1;
				break;
			case 4:
				paletteInc = -6;
				break;
			case 6:
				paletteInc = 6;
				break;
			default:
				break;
		}

		currentPalette = SAFEMOD(currentPalette + paletteInc, 36);

		ourCSSData[playerIndex].paletteIndex = currentPalette;

	},

	[](int playerIndex, int dir) mutable -> void {

	}

};

// -----

static Point moonRate(0.15, 0.15);

Smooth<Point> startingMoonSmoothPoint = Smooth<Point>(Point(0, 0), moonRate); // rate is what percentage of this bs to do per frame.
static Smooth<Point> moonPositions[4][3] = {
	{ startingMoonSmoothPoint, startingMoonSmoothPoint, startingMoonSmoothPoint },
	{ startingMoonSmoothPoint, startingMoonSmoothPoint, startingMoonSmoothPoint },
	{ startingMoonSmoothPoint, startingMoonSmoothPoint, startingMoonSmoothPoint },
	{ startingMoonSmoothPoint, startingMoonSmoothPoint, startingMoonSmoothPoint }
};

static Point paletteRate(0.15, 0.15);
std::array<std::array<Smooth<Point>, 36>, 4> palettePositions = []() { // i actually despise how this is the best option i have for doing this. and it isnt even proper bc i still need a () constructor
    
	Smooth<Point> startingPaletteSmoothPoint = Smooth<Point>(Point(0, 0), paletteRate); 

	std::array<std::array<Smooth<Point>, 36>, 4> res;

	for(int i=0; i<4; i++) {
		for(int j=0; j<36; j++) {
			res[i][j].current = Point(0, 0);
			res[i][j].goal = Point(0, 0);
			res[i][j].rate = paletteRate;
		}
	}
    
    return res;
}();


std::function<void(int playerIndex, Point p)> drawCharSelect = [](int playerIndex, Point p) mutable -> void {
	/*
	bool mirror = playerIndex & 1;
	DWORD bgCol = selfIndex == ourCSSData[playerIndex].selectIndex ? 0xFFFF0000 : 0xFF000000;

	dispPlayers[playerIndex]->gridPos = charGridList[ourCSSData[playerIndex].idIndex];
	players[playerIndex]->charID = charIDList[ourCSSData[playerIndex].idIndex];
	dispPlayers[playerIndex]->charID = players[playerIndex]->charID;
	dispPlayers[playerIndex]->palette = players[playerIndex]->palette;

	int displayIndex = playerIndex;
	if(displayIndex == 1) {
		displayIndex = 2;
	} else if(displayIndex == 2) {
		displayIndex = 1;
	}

	std::string tempCharString = "P" + std::to_string(displayIndex + 1) + ": " + charIDNames[ourCSSData[playerIndex].idIndex];
	RectDraw(x, y, cssMenuSelectorWidth, cssMenuFontSize, bgCol);
	TextDraw(x, y, cssMenuFontSize, 0xFFFFFFFF, tempCharString.c_str());
	y += cssMenuFontSize;
	*/

	for(int m=0; m<3; m++) {
		moonPositions[playerIndex][m].current = Point(0, 0);
		moonPositions[playerIndex][m].goal = Point(0, 0);
	}

	//TextDraw(p, cssMenuFontSize, 0xFFFFFFFF, "CHOOSE CHAR");
};

std::function<void(int playerIndex, Point p)> drawMoonSelect = [](int playerIndex, Point p) mutable -> void {

	// reset palette positions
	for(int pal=0; pal<36; pal++) {
		palettePositions[playerIndex][pal].current = Point(0, 0);
		palettePositions[playerIndex][pal].goal = Point(0, 0);
	}

	// upon entering moon select, if people have a random char selected, i need to give them a random char
	if(ourCSSData[playerIndex].idIndex == charIDCount - 1) {
		ourCSSData[playerIndex].idIndex = rand() % (charIDCount - 1);
	}

	if(ourCSSData[playerIndex].randomPalette) { // if we are in the moon state and randomPalette is still true, reset it
		ourCSSData[playerIndex].randomPalette = false;
	}

	constexpr const Rect* moonRects[] = {
		&UI::MoonCrescent,
		&UI::MoonFull,
		&UI::MoonHalf,
		&UI::MoonEclipse
	};

	static Point moonOffset(40, -180);
	static float moonScale = 4.0f;
	//UIManager::add("moonOffset", &moonOffset);
	//UIManager::add("moonScale", &moonScale);

	int moonIndex = CLAMP(players[playerIndex]->moon, 0, 3);
	int prevMoonIndex = SAFEMOD(moonIndex - 1, 3);
	int nextMoonIndex = SAFEMOD(moonIndex + 1, 3);
	
	static Point otherMoonOffset(20, 0);
	static float moonTransparency = 0.33;
	static float otherMoonScale = 4.0f;
	//UIManager::add("otherMoonOffset", &otherMoonOffset);
	//UIManager::add("moonTransparency", &moonTransparency);
	//UIManager::add("otherMoonScale", &otherMoonScale);	
	DWORD moonCol = (((BYTE)(0xFF * moonTransparency)) << 24) | 0x00FFFFFF;

	//UIManager::add("moonRate", &moonRate);
	/*for(int m=0; m<3; m++) {
		moonPositions[playerIndex][m].rate = moonRate;
	}*/

	moonPositions[playerIndex][moonIndex] = Point(0, 0);
	moonPositions[playerIndex][prevMoonIndex] = -otherMoonOffset;
	moonPositions[playerIndex][nextMoonIndex] = otherMoonOffset;

	Point centerPos = p + moonOffset + moonPositions[playerIndex][moonIndex];
	Point leftPos =   p + moonOffset + moonPositions[playerIndex][prevMoonIndex];
	Point rightPos =  p + moonOffset + moonPositions[playerIndex][nextMoonIndex];

	UIDraw(*moonRects[prevMoonIndex], leftPos, otherMoonScale, moonCol);
	UIDraw(*moonRects[nextMoonIndex], rightPos, otherMoonScale, moonCol);

	UIDraw(*moonRects[moonIndex], centerPos, moonScale, 0xFFFFFFFF); // so many issues would have been solved if i scaled this function to draw at texture center
	

};

std::function<void(int playerIndex, Point p)> drawPaletteSelect = [](int playerIndex, Point p) mutable -> void {

	const int width = 6;
	const int height = 6; // plus 1 for the random palette, but yea

	int palette = ourCSSData[playerIndex].paletteIndex;
	bool isRandomPalette = ourCSSData[playerIndex].randomPalette;
	int offsetPalette = ourCSSData[playerIndex].offsetPalette ? 36 : 0;

	static Point paletteOffset(40, -180);
	static float paletteScale = 12.0f;
	//UIManager::add("paletteOffset", &paletteOffset);
	//UIManager::add("paletteScale", &paletteScale);

	/*
	
	int x = palette / width;
	int y = palette % width;

	for(int i=0; i<7; i++) {
		Rect highlightRect;
		highlightRect.p1 = basePoint - Point(0 * paletteScale, 0);
		highlightRect.p2 = basePoint + Point(2 * paletteScale, paletteScale);

		if(i < 6) {
			DWORD highlightColor = (((x * 6) + i == palette) && !isRandomPalette) ? 0x40FFFFFF : 0x40000000;

			int paletteDisplayIndex = (offsetPalette ? 36 : 0) + (x * 6) + i + 1;
			
			if(paletteDisplayIndex > 64) {
				highlightColor = 0x40FF0000;
			}

			RectDraw(highlightRect, highlightColor);
			TextDraw(basePoint, paletteScale, 0xFFFFFFFF, "%02d", paletteDisplayIndex);
		} else {

			highlightRect.p2 = basePoint + Point(6 * paletteScale, paletteScale);

			DWORD highlightColor = isRandomPalette ? 0x40FFFFFF : 0x40000000;
			RectDraw(highlightRect, highlightColor);
			TextDraw(basePoint, paletteScale, 0xFFFFFFFF, "RANDOM");
		}
		
		basePoint.y += paletteScale;
	}
	*/

	int palX = palette / width;
	int palY = palette % width;

	Point basePoint = p + paletteOffset;

	static Point paletteDrawSize(30, 10);
	static Point paletteSize(6, 11);
	static Point paletteStartOffset(5, 4);
	static float fontSize = 10.0f;
	static Point paletteFontOffset(14, 0);
	static Point paletteColorSize(20, 10);
	static Point paletteColorOffset(10, 0);

	//UIManager::add("paletteDrawSize", &paletteDrawSize);
	//UIManager::add("paletteSize", &paletteSize);
	//UIManager::add("paletteStartOffset", &paletteStartOffset);
	//UIManager::add("paletteFontSize", &fontSize);
	//UIManager::add("paletteFontOffset", &paletteFontOffset);
	//UIManager::add("paletteColorSize", &paletteColorSize);
	//UIManager::add("paletteColorOffset", &paletteColorOffset);

	for(int x=5; x>=0; x--) {
		
		Point startOffset = (paletteStartOffset * x) + (Point(0, paletteSize.y) * 6);
		
		for(int y=6; y>=0; y--) {
			
			bool isRandomDraw = false;
			if(x != 0 && y == 6) { // prevents random from being drawn anywhere but x=0
				continue;
			} else if(y == 6) {
				isRandomDraw = true;
			}

			Point baseDrawPoint;

			if(isRandomDraw) {
				baseDrawPoint = basePoint + startOffset;
			} else {
				int paletteIndex = (((palX + x) % 6) * 6) + y;
				
				if(paletteIndex == palette && !isRandomPalette) {
					palettePositions[playerIndex][paletteIndex] = startOffset + Point(paletteStartOffset.x * 2, 0);
				} else {
					palettePositions[playerIndex][paletteIndex] = startOffset;
				}
				
				baseDrawPoint = basePoint + palettePositions[playerIndex][paletteIndex];
			}

			
			Rect drawRect;
			drawRect.p1 = baseDrawPoint;
			drawRect.p2 = baseDrawPoint + paletteDrawSize;

			DWORD color = 0xFF000000;
			DWORD borderColor = 0xFF646464;
			if(x == 0) {
				color = 0xFF000000;
				borderColor = 0xFFC8C8C8;
			}

			Point textPoint = drawRect.p1;

			if( ((x == 0) && ((palX * 6) + y == palette) && !isRandomPalette) || (isRandomPalette && (y == 6)) ) {
				drawRect.p1 -= Point(1, 1);
				drawRect.p2 += Point(1, 1);
				color = 0xFFFFFFFF;
				borderColor = 0xFFFF0000;
				
				DWORD animColor = 0xFF000000;
				switch(playerIndex) {
					case 0:
						animColor = 0xFFff0000;
						break;
					case 1:
						animColor = 0xFF00ca50;
						break;
					case 2:
						animColor = 0xFF0000ff;
						break;
					case 3:
						animColor = 0xFFff9d00;
						break;
					default:
						break;
				}
				borderColor = animColor;

				addAnimatedRect(drawRect, animColor);
			}

			RectDrawTex(drawRect, color);

			Rect drawRectOrig = drawRect;

			if(!isRandomDraw) {
				drawRect.p1 = baseDrawPoint + paletteColorOffset;
				drawRect.p2 = baseDrawPoint + paletteColorOffset + paletteColorSize;

				COLOR palColor = 0xFF00FF00;
				if(x != 0) {
					palColor.r *= 0.4;
					palColor.g *= 0.4;
					palColor.b *= 0.4;
				}

				RectDrawTex(drawRect, palColor);
			}

			BorderDrawTex(drawRectOrig, borderColor);

			if(x == 0) {
				int dispPaletteIndex = (palX * 6) + y;
				Point temp = shouldReverseDraws ? Point(2, 0) : Point(0, 0);
				if(y == 6) {
					TextDraw(textPoint + paletteFontOffset + temp - Point(8, 0), fontSize, 0xFFFFFFFF, "RND");
				} else {
					TextDraw(textPoint + paletteFontOffset + temp, fontSize, 0xFFFFFFFF, "%02d", dispPaletteIndex + offsetPalette + 1);
				}
			}
		
			startOffset.y -= paletteSize.y;
		}
	}

	

};

std::function<void(int playerIndex, Point p)> drawReadySelect = [](int playerIndex, Point p) mutable -> void {

	if(ourCSSData[playerIndex].randomPalette) { // we are here, pick a random palette
		ourCSSData[playerIndex].randomPalette = false;
		ourCSSData[playerIndex].paletteIndex = rand() % 36;
	}

	/*
	bool mirror = playerIndex & 1;
	DWORD bgCol = selfIndex == ourCSSData[playerIndex].selectIndex ? 0xFFFF0000 : 0xFF000000;

	RectDraw(x, y, cssMenuSelectorWidth, cssMenuFontSize, bgCol);
	TextDraw(x, y, cssMenuFontSize, 0xFFFFFFFF, "Ready(notworking)");
	y += cssMenuFontSize;
	*/	  
	TextDraw(p, cssMenuFontSize, 0xFF42e5f4, "READY");
};

std::function<void(int playerIndex, Point p)> DrawFuncs[] = { // i could pass in more params, but tbh ill just let each function do its own vibe
	drawCharSelect,
	drawMoonSelect,
	drawPaletteSelect,
	drawReadySelect
};

void drawCharSelectRect(int playerIndex) {

	bool shouldReverseDrawsBackup = shouldReverseDraws;
	shouldReverseDraws = false;

	int gridPos = charGridList[ourCSSData[playerIndex].idIndex];

	int x = gridPos % gridWidth;
	int y = gridPos / gridWidth;

	static Point basePoint(137, 42);
	static float width = 40;
	static float height = 45;
	static float boxWidth = 46;
	static float boxHeight = 55;

	//UIManager::add("base", &basePoint);
	//UIManager::add("width", &width);
	//UIManager::add("height", &height);
	//UIManager::add("boxWidth", &boxWidth);
	//UIManager::add("boxHeight", &boxHeight);

	Point drawPoint = basePoint + Point(x * width, y * height);

	DWORD boxColor = 0xFFFFFFFF;
	switch(playerIndex) {
		case 0:
			boxColor = 0xFFff0000;
			break;
		case 1:
			boxColor = 0xFF00ca50;
			break;
		case 2:
			boxColor = 0xFF0000ff;
			break;
		case 3:
			boxColor = 0xFFff9d00;
			break;
		default:
			break;
	}

	Rect r(drawPoint, drawPoint + Point(boxWidth, boxHeight));

	addCharRect(r, boxColor);

	shouldReverseDraws = shouldReverseDrawsBackup;

}

// ------

const int menuOptionCount = sizeof(ControlFuncs) / sizeof(ControlFuncs[0]);
static_assert(sizeof(DrawFuncs) / sizeof(DrawFuncs[0]) == sizeof(ControlFuncs) / sizeof(ControlFuncs[0]), "each DrawFuncs must have a controlfunc!");

bool inStageSelect = false;

void cssInit() {

	log("css inited");

	static bool firstInit = true;
	if(firstInit) {
		firstInit = false;
		ourCSSData[0].idIndex = 0; // sion
		ourCSSData[1].idIndex = 10; // vsion
		ourCSSData[2].idIndex = 1; // arc
		ourCSSData[3].idIndex = 11; // warc
		srand(time(NULL));
	}

	// on init, set all css phases to 1 so that caster doesnt block B inputs
	for(int i=0; i<4; i++) {
		dispPlayers[i]->cssPhase = 1;
		dispPlayers[i]->cssPhase = 1;
		ourCSSData[i].selectIndex = 0;
	}

	inStageSelect = false;

}

extern "C" {
    DWORD stageSelEAX = 0;
}

void stageSelCallback() {

	if(!inStageSelect) {
		stageSelEAX = 0xFFFFFFFF;
		inStageSelect = false;
	}

}

void enterStageSel() {

	if(inStageSelect) {
		return;
	}

	inStageSelect = true;

	dispPlayers[0]->cssPhase = 5;
	dispPlayers[1]->cssPhase = 5;

}

void leaveStageSel() {

	if(!inStageSelect) {
		return;
	}

	log("leaveStageSel");

	inStageSelect = false;

	dispPlayers[0]->cssPhase = 1;
	dispPlayers[1]->cssPhase = 1;

}

void updateControls() {

	// handle controls
	// idk where i should grab controls from either, what reads the stuff melty writes to? or i could be safe with a direct melty write, but have to keep track 
	// of presses myself
	// maybe one less patch tho

	for(int i=0; i<4; i++) {

		ourCSSData[i].input.set(i);

		BYTE pressDir = ourCSSData[i].pressDir();
		pressDir |= ourCSSData[i].holdDir();
		BYTE pressBtn = ourCSSData[i].pressBtn();

		// this needs refactoring

	
		//if(inStageSelect) {
		if(*(BYTE*)(0x00773158 + 0x3C) == 0x01) {
			if(pressBtn == 0x20) { // B press
				leaveStageSel(); // does this even work.
				return; // this return might do some weird shit, but not having it would be worse
			}
		} else {
			if(pressBtn) {
				if(pressBtn & 0x10) { // A
					ourCSSData[i].selectIndex++;
					if(ourCSSData[i].selectIndex >= menuOptionCount) {
						ourCSSData[i].selectIndex = menuOptionCount - 1;
					}
				} else if(pressBtn & 0x20) { // B
					ourCSSData[i].selectIndex--;
					if(ourCSSData[i].selectIndex < 0) {
						ourCSSData[i].selectIndex = 0;
					}
				} else if((pressBtn & 0x0C) && ((ourCSSData[i].input.btn & 0x0C) == 0x0C)) { // caster is fucking with p/2/3 on subsequent loads. am i not resetting correctly? its randomly having 0x02 btn
					ourCSSData[i].offsetPalette = !ourCSSData[i].offsetPalette;
				}
			} else {
				switch(pressDir) {
					case 2:
					case 8:
					case 4:
					case 6:
						ControlFuncs[ourCSSData[i].selectIndex](i, pressDir);
						break;
					default:
						break;
				}
			}
		}
	
		ourCSSData[i].prevInput = ourCSSData[i].input;
	}

	// check if i should move ppl to css
	bool shouldMoveToCSS = true;
	for(int i=0; i<4; i++) {
		if(ourCSSData[i].selectIndex != menuOptionCount - 1) {
			shouldMoveToCSS = false;
			break;
		}
	}

	if(shouldMoveToCSS) {
		enterStageSel();
	}

}

void updateMeltyState() {
	for(int playerIndex=0; playerIndex<4; playerIndex++) {

		if(!ourCSSData[playerIndex].randomPalette) {
			players[playerIndex]->palette = (ourCSSData[playerIndex].offsetPalette ? 36 : 0) + ourCSSData[playerIndex].paletteIndex;
			players[playerIndex]->palette = CLAMP(players[playerIndex]->palette, 0, 63);
		}
		
		dispPlayers[playerIndex]->gridPos = charGridList[ourCSSData[playerIndex].idIndex];
		players[playerIndex]->charID = charIDList[ourCSSData[playerIndex].idIndex];
		dispPlayers[playerIndex]->charID = players[playerIndex]->charID;
		dispPlayers[playerIndex]->palette = players[playerIndex]->palette;
	}	
}

void drawCSS() {

	if(*(BYTE*)(0x00773158 + 0x3C) == 0x01) { // in stagesel, dont draw
		return;
	}
 
	constexpr Point anchors[4] = { // coords grabbed from _naked_modifyCSSPixelDraw
		Point(60 + 80, 448),
		Point(60 + 80, 448),
		//Point(640 - 60 - 80, 448),
		Point(60, 300),
		Point(60, 300)
		//Point(640 - 60, 300)
	};

	for(int i=0; i<4; i++) {

		shouldReverseDraws = (i & 1);

		Point p = anchors[i];

		drawCharSelectRect(i);

		DrawFuncs[ourCSSData[i].selectIndex](i, p);
	}
	
}

void updateCSSStuff(IDirect3DDevice9 *device) {

	updateControls();

	updateMeltyState();

	drawCSS();

	shouldReverseDraws = true;
	TextDraw(10, 10 + (0 * 8), 8, 0xFFFFFFFF, "please follow me on twitter so i have motivation for this");
	TextDraw(10, 10 + (1 * 8), 8, 0xFFFFFFFF, "@Meepster99");
	TextDraw(10, 10 + (2 * 8), 8, 0xFFFFFFFF, ":3");
	
	shouldReverseDraws = false;
	if(updateOccured) {
		TextDraw(10, 450 + (0 * 8), 8, 0xFF42e5f4, "A new update was downloaded. Restart melty please.");
	}
	TextDraw(10, 450 + (1 * 8), 8, 0xFFFFFFFF, "send bug reports in https://discord.gg/vzvyjz775r");
	TextDraw(10, 450 + (2 * 8), 8, 0xFFFFFFFF, "Version: %s", LocalVersion.revision.c_str());

}
